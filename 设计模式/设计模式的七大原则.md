# 面向对象设计的七大原则

### 单一职责原则 (Single Responsibility Principle, SRP)

> 定义: 一个类只负责一个功能领域中的相应职责，或者可以定义为，就一个类而言，应该只有一个引起它变化的原因。

因为，在软件系统中，一个类(大到模块，小到一个方法)，如果承担的职责太多，那么它被复用的可能性就越小，耦合度也就越高，当这个类里面的职责发生变化的时候，就可能会影响到其他职责的运作。因此，需要将这个臃肿的类的职责分离出来，将不同的职责分别封装成不同的类中，这样当其中的一个职责发生变化，也不会影响到其他职责的运作。单一职责告诉我们，**一个类应该只有一个引起它变化的原因**： **即将不同变化的原因分别封装到不同的类里面，如果多个职责总是同时发生变化，则将这些同时发生变化的原因封装在一起。**



在日常的软件开发过程中，单一原则既是最容易的也是最难实现的一项原则。在现实的开发过程中，总会遇到需求变更或对需求理解不透彻等等原因，一个原本已遵循单一原则的类违背了单一原则，这是因为在现实的开发过程中会有一个**职责扩散**的一个现象。在某一个阶段，类T只是实现该功能，但是在后续的时间里，类T需要实现其他功能，而此时如果类T继续遵循单一职责的话，类T则会抽出为T1、T2、Tn....，这样的一个过程既浪费时间也增加了项目的复杂度，因而，单一职责这个原则并不是在任何情况下都适用，需要根据显示情况酌情而定，而不是为了设计而设计！



### 开闭原则 (Open-Closed Principle, OCP)

> 定义: 一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展

开闭原则中定义中，软件实体可以是指一个软件模块、一个由多个类组成的局部结构，或者说是一个类。



开闭原则所面对的问题是，<u>随着时间的推移，软件的需求会发生不断地变更。当面对新的需求时，我们应当尽量保持系统所设计的框架是稳定的</u>。如果一个软件的设计遵循着开闭原则，那么久可以非常方便地对系统进行拓展，而且在拓展的时候，无需修改现有的代码，软件系统在拥有适应性和灵活性的同时，具备较强的稳定性和延续性。



开闭原则的关键是**抽象化**，需要对软件系统进行**抽象化设计**。在Java、C#中可以定义一个相对稳定的抽象层，而将不同的行为实现放置在实现层中实现。在很多面向对象编程语言中都提供了接口、抽象类等机制，可以通过它们定义系统的抽象层，再通过具体类来进行扩展。如果需要修改系统的行为，无须对抽象层进行任何改动，只需要增加新的具体类来实现新的业务功能即可，实现在不修改已有代码的基础上扩展系统的功能，达到开闭原则的要求。







### 里氏代换原则 (Liskov Substitution Principle, LSP)

> 定义: 如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1代换o2时，程序P的行为没有变化，那么类型S是类型T的子类型

通俗的讲，里氏代换原则可以表述为： 所有引用基类（父类）的地方必须透明地使用其子类的对象，反之则不行。里氏代换原则告诉我们，在软件中将一个基类替换成它的子类，程序将不会产生报错和异常。反之则不成立。

如果一个软件实体使用的是子类对象的话，那么它一定不能够使用基类对象。比如说，我喜欢动物，那么我肯定喜欢狗，因为狗属于动物的一个子类。反过来说，我喜欢狗，但并不能说明我喜欢动物，我可能讨厌猫，猫也是属于动物的一类。所以，里氏代换原则告诉我们，在一个功能设计中，如果使用的是基类对象，那么一定可以使用这个基类的子类对象。

使用里氏代换原则需要注意的几个地方：

1. 子类的所有方法必须在父类声明，或者说子类必须实现父类的所有方法。根据里氏代换原则，为了保证系统的拓展性，在程序中使用父类来定义子类的行为。如果一个方法只在子类中有效，父类不提供相应的声明，则无法以父类定义的对象中使用该方法。
2. 在使用里氏代换原则中，尽可能的讲父类设计成抽象类或者接口，让子类继承父类的来实现其中的方法。运行的时候，使用子类的实例来替换父类的实例。这样，我们便可以很方便的拓展程序的功能，同时无需修改原有的子类代码，新增加的功能可以通过增加一个新的子类来实现。





### 依赖倒转原则 (Dependence Inversion Principle, DIP)

...



### 接口隔离原则 (Interface Segregation Principle, ISP)

...



### 合成复用原则 (Composite Reuse Principle, CRP)

...



### 迪米特法则 (Law of Demeter, LoD)

...